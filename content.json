{"meta":{"title":"Reficul","subtitle":null,"description":null,"author":"Reficul","url":"https://reficul.io","root":"/"},"pages":[],"posts":[{"title":"我是怎么从WoW AFK的","slug":"why-am-i-afk-from-wow","date":"2021-02-21T22:40:45.000Z","updated":"2021-02-21T17:44:28.143Z","comments":true,"path":"2021/02/21/why-am-i-afk-from-wow/","link":"","permalink":"https://reficul.io/2021/02/21/why-am-i-afk-from-wow/","excerpt":"这是一个八九年前的真实故事，请原谅我的旧事重提。 2009年的初见之后的第3年，我选择了AFK。 之所以今天突然旧事重提，是因为看到有人对《阿甘正传》中阿甘突然选择了在某一天停止了持续几年的长跑的一则解读；又大抵是在因为距离上次删掉所有矫情文章封笔已经有13年了，这段时间内喷薄欲出的无病呻吟已经积攒到了一个程度吧。","text":"这是一个八九年前的真实故事，请原谅我的旧事重提。 2009年的初见之后的第3年，我选择了AFK。 之所以今天突然旧事重提，是因为看到有人对《阿甘正传》中阿甘突然选择了在某一天停止了持续几年的长跑的一则解读；又大抵是在因为距离上次删掉所有矫情文章封笔已经有13年了，这段时间内喷薄欲出的无病呻吟已经积攒到了一个程度吧。 为了方便读者理解，首先解释一下名词： WoW：全称 World of Worldcraft，中文翻译《魔兽世界》，是美国暴雪公司在2004年推出的一款大型多人在线角色扮演类游戏（MMORPG）。 推出之后一时之间一度封神，开创了游戏领域的一个新篇章，在相当一定时间内无人能望其项背，更是暴雪之后十多年内最重要的现金牛。截止到2021年的现在，虽然颓势已现，时代的变化使他无法再与新一线相比，但是仍然一己之力供给着暴雪最大的利润，可谓瘦死的骆驼比马大。 AFK：全称Away From Keyborad，直译是『暂时离开键盘』，而后又衍生出了一去不回即弃坑的意思。 一切机缘来自朋友的安利，而热爱并沉迷的原因则来自一个无聊灵魂对时间的无处安置。当时还在读高中，WoW作为一项娱乐爱好所能分配的时间十分有限。因此，周末和天各一方的陌生人合作，推进副本进度是一件奢侈且不现实的事情。所以当时我的玩法主要是休闲，没有那么多功利心，任何的收获都是惊喜。仿佛是一个走在海边的小孩，懵懂且毫无目地的在沙滩边上探索，无论是捡到一个贝壳亦或是一个螃蟹都能激动半天。十来年过去了，我至今还能清晰的记得，在深夜在满是红名NPC的敌对主城和两个素昧平生的陌生人花了大半个小时偷偷磨死了首领(呃，抱歉了阿强)之后的狂喜，而这种喜悦是之后再也不曾体验到的。 之后，高中毕业读大学了。大学，正所谓大把的时间作除了学。 对突如其来的富足时间一时之间除了玩物丧志竟不知道还能做啥，当时打游戏就像老鼠掉进了米缸。拉上专业里几个志同道合的新同学，我们的工会团队便组建好了。一个10人的团队，往往需要1个核心指挥，2个坦克，2到3个治疗以及若干伤害输出。 由于牵头的已有其人，那么他作为核心指挥自然义不容辞；而当时团队没有治疗，碰巧作为团队唯一的牧师，自然没有了打输出的机会。虽然每个牧师都有一个打输出的心，但是毕竟团队需要我是吧？ 我记得当时是2011年，我们面对的版本是大灾变的4.1版本， 这是一个复古的版本， 即使是5人难度的小副本对治疗的压力也是非常大。为了减少团队开荒10人团队副本的压力，那段时间可是废寝忘食。一周高强度的准备之后，我是基本上差不多了，而此时发现队友竟然在玩小号没好好准备。呃，看起来服务器首杀是没机会了。打击了一顿积极性，沮丧归沮丧，但除了首杀，游戏最重要的还是朋友。 这段时间虽然土法炼钢了点，队友虽然有时不太靠谱了点，虽然副本进度拖垮了点，但是我们是快乐的。这段时间里，我们的工会一直在壮大，团队在发展，除了最初线下的同学们，我们还结识了一些五湖四海的朋友。比如一个从不说话的牧师Niaomi，到最后AFK才知道是一个妹子，而她的AFK原因则是准备创业，要全职在北京开咖啡店了，不知现在是否一切顺利，祝好。 而事情的转折点是一年多后，我们的指挥团长休学参军了，当时我们刚在版本末班车刚推倒了4.3的关底Boos死亡之翼，准备挺进5.0熊猫人版本。核心指挥的离开导致我们不得不和隔壁工会进行合并，起初谈判的很好：由他们会长负责指挥，我则负责DKP的清算。（这里简单解释下DKP：Dragon Kill Point, 即屠龙点数，参加工会活动击杀Boos获得，并在之后用来兑换Boss掉落的装备，类似于工会内的工资。）当时正在开荒恐惧之心，这个副本难度很多非常依赖队友的默契程度。工会的合并造成人员不稳定，继而造成团队在开荒时候发生了很多无意义的错误，接连团灭好几个晚上是常有的事情。虽然过去之前的队友也坑，但基本上都是较熟的朋友，过程往往比较随意欢乐，而现在不同了：更多的人是来为了装备来混DKP的，而我这个管“钱”的还得一碗水端平。渐渐的，不知道什么时候感觉这个游戏越来越累，好像全勤上线是就为了清算所有人的DKP。后面，为了防止DKP的恶意囤积，新人不友好等问题，我一直想采用了EPGP机制，并且希望用Git来管理每天活动的数字变化从而做到透明可追溯。而令我没想到的是，因为EPGP算法复杂，Git门槛高导致这项企划受到了对方工会所有人的质疑和不信任，到了后面甚至一度要求换人来对DKP进行清算。与此同时，我也感觉到主键被架空。但是此时的我，压力和盲目的忙碌让我还没意识到这个游戏已经变了味，我每天还是和上班一样一天不落地上线。 在此之间，现实生活中也发生了一件事情很大程度上影响到了我。学校组织了一个调研/演讲的活动。而正所谓无利不起早，为了鼓动学生参加，只要参加就可以有好处（记不清是不是学分了），当时头一热就和室友4个人报了名。 活动需要到期之后上交小论文和演讲一次，听到这个队友都打起了退堂鼓。作为报名者，这个重任只能落到了自己头上。 活动正式开始后，队友就开始了划水模式，百度了几个简报就想敷衍过去。骑虎难下的我只能自己准备材料，而准备材料的几个礼拜里，自然是对舍友怨声载道。直到最后活动那天矛盾彻底爆发，导致后来与3个舍友彻底决裂只能搬出去自己住。后来反思了下，队友懈怠是是客观原因，而我的确不知道应该要怎么做一个队长：之前没好好拆分工作项，而执行过程太软弱导致没人理，难得严厉了又导致自己曲高和寡。从这件事我认清了一个事情：做一个Team Leader是需要技巧的，而我显然没有这方面天赋。 回到AFK的事情上，这和一般的故事不一样的是这个故事没有压死骆驼的最后一根稻草，AFK那天的到来是无比自然的。 当时是个寒假，我在顺电做兼职，负责在线下店卖数码。呃，是的，我除了会折腾对于销售也挺拿手的。 一天下班后，我没有和往常一样点开游戏，那天我只是想看电视。 工会活动的时间到了，会长打来电话催促。我看着手机上来电的名称，只有一种『害怕，想逃』的情绪，在思考前我就按下了静音按钮。 是的，我没有挂断，就只是装作是没有看见一样。几个重播的来电之后，手机恢复平静了，而我得到的却是一种解脱的感觉。 那天之后， 每天上线的我再也没上线。","categories":[],"tags":[{"name":"pulp life","slug":"pulp-life","permalink":"https://reficul.io/tags/pulp-life/"}]},{"title":"Prometheus最佳实践 --- INSTRUMENTATION","slug":"prometheus-best-practices-instrumentation-md","date":"2019-12-22T23:43:28.000Z","updated":"2021-02-21T17:44:28.143Z","comments":true,"path":"2019/12/22/prometheus-best-practices-instrumentation-md/","link":"","permalink":"https://reficul.io/2019/12/22/prometheus-best-practices-instrumentation-md/","excerpt":"0x00本文旨在对如何设计监控方面提供一些意见性的指导和建议。 本文章翻译自Prometheus官方文档：Best Pratices-INSTRUMENTATION","text":"0x00本文旨在对如何设计监控方面提供一些意见性的指导和建议。 本文章翻译自Prometheus官方文档：Best Pratices-INSTRUMENTATION 0x01 要怎么监控？简单地来说，就是监控所有东西：对于任何一个库(Library)，子系统(SubSystem)或者服务(Service)来说，都至少应该有几个指标来告诉你他们现在的运行状况。数据采集应该是代码里不可或缺的一部分。这能够在你调查错误的时候，能更容易的从告警着手，进而联系到控制台和代码里去。 服务可以被分为三类根据监控的目地，服务通常可以分为以下三类：在线服务、离线服务以及批处理任务。虽然这三种服务的定义互相之间略有重叠，但是基本上所有的服务都可以很好的被纳入其中之一里去。 在线服务如果一个人或者其他的系统期望在这个系统里能够立即得到响应，那么这个系统就是一个在线系统。打一个比方，大部分的数据库、HTTP服务都归于此类。 对于这种系统而言，关键监控指标就是发生的“查询（query）数量”、“错误(error)数量”以及“延迟(latency)情况”。同样而言，如果把这些指标项套用在当前正在处理中的请求上的话，也是十分具有意义的。 而对错误的监控方面的建议，请直接参考下文的错误章节。 对于是属于“在线服务”类的系统而言，应该同时监控它的服务端和客户端。因为如果看到两边的指标数据不一样了，那么这个事情对于Debug是非常有帮助的。不过，如果一个服务里存在有非常多的客户端，以至于无法一一地追踪客户端的状态，那么也只能依靠它们自己的统计数据了。 另外，在对查询（query）进行计数的时候，要么全部在操作开始前，要么都在结束后。 在结束后进行计数是比较推荐的，因为这能够对错误和延迟状况进行统计，而且写起代码来也更简单。 离线服务对于离线服务而言，不会有人会干等着响应回来，而任务基本上是成批的，并且基本上处理过程都得分为好几个阶段。 针对每一个阶段，追踪每一个扇入的任务，有多少个任务正在处理，上次处理任务的时间，扇出了多少个任务。如果是批量任务的话，那对进出的批次也应该追踪起来。 知道“上次处理任务的时间”这个信息对判断系统有没有挂掉是一个很有用的信息，但是这个信息具有很大的局限性。更好的做法是将心跳信息贯穿整个系统：加入一些带有时间戳的虚拟任务，并将这些任务在系统内一直传递下去。在每个处理阶段内，都把他们观察到的最近一次的心跳时间戳暴露出来。因为对于在不在处理任务时也不存在静默期的系统而言，是不需要其他明确的心跳信息的。 批处理任务对于离线任务和批处理任务而言，其中的界限是比较模糊的，这是因为离线处理很有可能就是一个批处理任务。因此，在这是用他们是否需要持续运行来区分是不是批处理任务，因为就是这点导致了收集他们的信息十分的困难。 对于批处理任务而言，关键的指标就是上次任务成功的时间。另外，追踪任务在主要处理阶段所花费的时间，总体的运行时间以及上次任务完成时间（无论是成功还是失败）都是很有帮助的。这部分数据应该全都是Gauge类型的，而且都应该直接推到PushGateway里进而完成收集。另外在通常情况下，一些总体性的与任务相关的数字也是很有意义的，例如已处理的任务总数之类的。 针对那些要跑好几分钟的批量任务而言，基于拉的监控模式也是挺好的。这可以让你观察到同一个监控指标在执行不同类型的任务的时候的区别，例如资源使用率，与其他系统交互时候的延迟等等。这些信息对于调查诸如任务处理开始变慢的问题的时候，是非常具有参考意义的。 针对于那些跑得非常频繁（一般来说，小于15分种跑一次就算频繁）的任务而言，你就应该考虑将这些任务转换成一个常驻服务，并将其当作离线任务来处理。 子系统（SubSystem）除了按三种基本服务类型来监控以外，系统中也有一些部分需要被监控起来。 依赖库（Libraries）依赖库应该提供一些无需用户额外配置的监控方式。 如果一个库是用来从外部去拿一些资源信息的（比如网络，磁盘，IPC等），理应对他们总体的每分钟调用数量，错误数量（如果有可能发生）以及延迟情况进行统计。 根据被依赖的库的复杂程度，来追踪依赖库内部产生的内部错误以及延迟情况，或是任何你认为有用的通用统计数据。 一个依赖库也很有可能被一个应用内的完全不同的部分独立的调用了，所以注意使用合适的标签（Label）来区分彼此。 打一个比方：一个数据库链接池应该以它连接到的数据库来区分，但是对于DNS客户端库而言就没必要进行区分了。 日志有一个通用的规则：对于每一条日志而言你都应该对于有一个自增的计数器来对其计数。这是因为，如果你在对某条日志比较感兴趣的时候，你很有可能会想知道它多久发生一次，以及每次发生持续多久。 如果在一个函数里有多个很接近的日志的话（例如在If/Switch的不同分支里），那么这时候也可以用一个计数器来代表他们所有。 通常情况下，对应用日志的INFO/ERROR/WARNING日志总条目进行计数是很有用的，这能够用于在发布过程中检查其有没有较大的差异。 错误处理错误处理应该和日志比较相近。每次有错误发生，一个计数器就应该自增。但是和日志不同的是，错误通常会向上传递到一个更宽泛的错误计数器之上，这通常取决于你的代码结构。 当汇报错误的时候，你通常应该有其它一些代表总共尝试次数的指标，进而能够用这些信息来计算出错误率。 线程池对于任何类型的线程池而言，最重要的指标就是请求队列的深度，当前的线程数量，线程池线程的总数，处理的任务数量，以及处理任务所消耗的时间。当然，追踪任务在队列中等待的时间也很有用的。 缓存对于缓存来说，主要的监控指标是总查询次数，缓存命中次数，总体延迟时间。而对于任意在线系统前的缓存而言，则是查询次数，错误次数以及延迟。 收集器（Collector）对于实现一个重要的自定义指标收集器而言，有一条建议是将收集器每秒消耗的时间以及其发生的错误次数进行记录，通过Guage的方式进行导出。 只有两种情况下可以将一个事情发生的持续时间用Guage形式导出，上述场景就是其中的一种，另外一种情况则是批处理任务的持续时间。这是因为这两种场景分别代表了搜刮和推送特定信息的场景，并非是要随着时间的推移追踪多个事件的持续时间。 0x10 注意事项这部分里总结了一些注意事项是做监控时通用的，但其中也有一些与Prometheus特定相关的部分。 使用标签很少有监控系统用标签和计算表达式的概念作为卖点，因此在这点上需要花点时间来习惯一下。 当你希望有多个指标需要对其求增量/平均值/求和的时候，这些指标通常能够被整合到一个指标里去，而不是利用多个指标来进行收集。 举一个例子：比起用’http_responses_500_total’和’http_responses_403_total’两个指标而言，更好的做法是直接创建一个指标叫做’http_responses_total’，其中用’code’作为标签名来代表返回码 。通过这种方式，一整套指标就能够用同一套规则和视图来进行处理了。 按照经验规则，监控指标的名称中任何一部分都不应该是程序生成的，需要生成的部分就应该使用标签。但是如果指标是来自于其他的监控系统，那么需要处理这样的代理指标可以的场景可以作为一种例外情况来特殊对待。 此外，更多关于命名相关的建议可以参考命名相关的章节。 不要滥用标签每个标签组合都是一个额外的时间序列，都会会给内存/计算/存储以及网络带来一定的资源消耗。虽然通常来说这个消耗是可以忽略不计的，但放到几百个机器上有一堆有上百个标签的指标的场景来看的话，资源的消耗量肯定是会急剧增加的。 通常情况下，尽可能的保持你的监控指标的标签数量小于10。对于超出这个数量级的指标，尽可能确保它在系统中是一个少数情况。对于大多数的监控项都是不应该带有标签的。 如果有一个监控指标的标签数量大于100，而且还有变得更大的可能的话，就需要想办法给它找一个替代方案了。诸如减少指标的维度，或者将其从实时监控系统移到别的通用数据处理系统里去了。 为了让你有一个对底层数字更好的认识，这里以node exporter为例。node exporter将会暴露每个已挂载的文件系统的监控指标，因此每台机器都会有十几个叫node_filesystem_avail的时间序列。 如果你有10,000台节点的话，最终单node_filesystem_avail就会大概有超过100,000个时间序列了。如果只在这种情况下，Prometheus还是没啥问题的。 但是糟糕的是如果现在你又为每个用户添加了磁盘配额的设定，即在10,000个节点上有10,000个用户，那么这很快就会给原本百万级别的数量级再带来两位数的提升。这个数字对于Prometheus当前的实现来说就太多了！ 但是即便对于数量小一些，那也存在一定的机会成本。因为在这个机器上，你已经无法去收集一些别的更有潜力有价值的指标了。 综上，如果你不确定是否应该加上标签，那么最好一开始的时候先别加，在之后有具体的使用场景的时候再加也不迟。 Counter vs. gauge, summary vs. histogram对于监控来说，知道什么时候该用四种指标类型中的某一个是至关重要的。 在Counter和Gauge类型的选择中， 只有一条简单的经验规则：如果指标的值会下降，那就用Guage。 因为Counter类型只能够单调递增（虽然可能重置，不过这只发生在被监控的进程重启的时候）。也正因为这个特点，Counter在累计一些事件发生的次数或是每个事件里事物的数量的场景下特别有用。举一个例子：HTTP请求的发生的总次数，或是HTTP请求已发送的总字节数。Counter的值如果直接用一般没啥意义，一般都会搭配rate函数来计算它每秒的自增量。 Gauges类型的值能够被直接设置一个大小，或者变大/变小。这点在需要对当前状态收集一个快照的时候尤为有用。例如当前处理中的请求数量，空闲/总内存数量，或者温度。对于Gauge类型的指标，你永远不应该对其使用rate函数进行求值。 Summaries和Histograms类型就比上面两种复杂太多，这部分会在他们自己的章节中单独讨论。 具体的时间戳，而非相对时间如果你需要追踪一个事情自发生以来的持续时间，在导出指标数据的时候，导出事件发生时间的Unix时间戳而非相对于当前时间的持续时间。 而对于已导出的时间戳数据，可以用过time函数减去事件发生的时间戳来计算出事件的持续时间。通过这种方式能够避免对数据进行更新操作，进而保护在更新操作的时候发生卡住的现象。 循环内通常情况下，监控带来的资源消耗相比于它对运维和开发时候带来的好处，利是远大于弊的。 但是对于那些进程里性能至关重要的部分，或是每秒都会被调用大于100k次的部分来说，你就应该需要考虑每次需要更新的指标有多少了。 对于一个Java的Counter来说，根据实际情况大概需要12-17纳秒来完成计数操作，这点在别的语言里的性能也差不多。如果在循环里有一些第哦时间消耗敏感的部分，那就应该对需要计数的指标数量进行一些限制，并且尽可能避免在循环内去使用标签查找操作（可以在循环外把根据标签查找到的结果进行一个缓存，例如把With方法（Go）/labels方法(Java)返回的缓存起来。） 另外需要注意的是，更新涉及时间/持续时间的监控指标有可能会调用系统调用。因此，对于那些有性能敏感的代码来说，跑一个Benchmark才是判断性能影响方面最好的办法。 避免缺失指标在事件还没发生前不进行上报的那种时间序列是很难被处理的，通常的处理方式都无法正确处理他们。因此用将所有已知在之后会出现的时间序列都用 0 导出（其中如果0会导致被误解的话，那么就导出一个NaN）的方式来避免这种情况的发生。 大多数Prometheus的SDK（包括Go/Java/Python）都会自动为你将没有标签的指标用 0 进行导出。","categories":[],"tags":[{"name":"Prometheus","slug":"Prometheus","permalink":"https://reficul.io/tags/Prometheus/"},{"name":"Best Practices","slug":"Best-Practices","permalink":"https://reficul.io/tags/Best-Practices/"},{"name":"Instrumentation","slug":"Instrumentation","permalink":"https://reficul.io/tags/Instrumentation/"},{"name":"最佳实践","slug":"最佳实践","permalink":"https://reficul.io/tags/%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"}]},{"title":"Golang黑魔法(1)：使用其他包中未导出的函数","slug":"go-dark-magic-1","date":"2019-02-19T00:03:31.000Z","updated":"2021-02-21T17:44:28.143Z","comments":true,"path":"2019/02/19/go-dark-magic-1/","link":"","permalink":"https://reficul.io/2019/02/19/go-dark-magic-1/","excerpt":"Go是一门语法以Less is More为哲学的语言，以简单易学为设计目标，致力于写出比Java还千人一面的符合工程要求的语言。GC、没有泛型、简单到没有的错误处理等等，都使得我这种不会管理内存，智商跟不上泛型，只要Try就Catch不到的小学生能够每天拼接一下字符串，勉强过得了生活的样子。但是，不信任用户的同义词就是只信任自己：“不让你用是怕你搞砸，至于我？我怎么可能搞砸？”。为了方便那些Go Author，他们早就给自己开好了后门。但是这些技巧最大的作用就是茶余饭后的装逼资本了，毕竟在项目里用了很可能就被买腿了。但是话说回来，黑魔法一般作为禁招也能够帮你绝处逢生，离开你地球就停转，从而保住饭碗。","text":"Go是一门语法以Less is More为哲学的语言，以简单易学为设计目标，致力于写出比Java还千人一面的符合工程要求的语言。GC、没有泛型、简单到没有的错误处理等等，都使得我这种不会管理内存，智商跟不上泛型，只要Try就Catch不到的小学生能够每天拼接一下字符串，勉强过得了生活的样子。但是，不信任用户的同义词就是只信任自己：“不让你用是怕你搞砸，至于我？我怎么可能搞砸？”。为了方便那些Go Author，他们早就给自己开好了后门。但是这些技巧最大的作用就是茶余饭后的装逼资本了，毕竟在项目里用了很可能就被买腿了。但是话说回来，黑魔法一般作为禁招也能够帮你绝处逢生，离开你地球就停转，从而保住饭碗。 Pragmas （编译指示）Go作为一门静态语言，和别的语言一样需要经过编译，链接。而编译指示就是在这个过程中，额外输入给编译器或者连接器的信息。利用这些指示，可以绕开或者做到一些特殊的功能。这些功能被只言片语的从官方文档中带过了，或者根本就没写。无论写没写，可以看得出来的是：官方的确不太想让普通用户都知道这些。 Go:linkname回到主题，本文主要打算介绍一个比较安全的黑魔法：Linkname。利用这个Pragmas，可以使得编译器仅仅保留一个符号，并在链接的过程中将这个符号链接到目标上去。废话不再多说，直接上例子： 12345678910111213package mainimport ( _ \"unsafe\" \"fmt\")func main() &#123; fmt.Println(isSpace(' '))&#125;//go:linkname isSpace fmt.isSpacefunc isSpace(r rune) bool 在这个例子里，可以很明显的发现13行的isSpace这个函数只有签名没有函数体，取而代之的是上面有一行注释。代码13行的注释使用了go:linkname这个Pragmas，而他的意思也不复杂：将isSpace这个函数链接至fmt包中的未导出函数isSpace。但是，由于这种操作其实并不推荐，因为他会破坏包的封装，所以需要导入unsafe包来敲打你一下。 现在万事俱备，直接运行go build来编译一下验证一下结果：返回./main.go:14:6: missing function body错误。其实这是go build命令行工具没有支持这样的操作，为了使用黑魔法必须手动逐步编译和链接。示例命令如下： 1234$ go tool compile main.go$ go tool link -o main main.o$ ./main&gt; true 值得一提的是，如果使用的是CGO或者需要链接至别的二进制库，需要在go tool link后使用-L参数指定二进制位置。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/tags/Golang/"},{"name":"dark magic","slug":"dark-magic","permalink":"https://reficul.io/tags/dark-magic/"},{"name":"pragmas","slug":"pragmas","permalink":"https://reficul.io/tags/pragmas/"}]},{"title":"用Blaze实现Golang泛型","slug":"go-generic-type-with-blaze","date":"2019-02-09T04:45:16.000Z","updated":"2021-02-21T17:44:28.143Z","comments":true,"path":"2019/02/09/go-generic-type-with-blaze/","link":"","permalink":"https://reficul.io/2019/02/09/go-generic-type-with-blaze/","excerpt":"Golang是一门工程语言，语法元素很少很容易掌握。从而，只要不是太扯的人写出来的代码理应相差不大，并能够很快被人理解。泛型在现代编程语言中被广泛使用，这里不谈Go缺失泛型是否是一种糟糕的设计，纯粹前段时间在gvisor的代码中看见一种实现泛型的方式比较新奇，因此拿来记录一下。","text":"Golang是一门工程语言，语法元素很少很容易掌握。从而，只要不是太扯的人写出来的代码理应相差不大，并能够很快被人理解。泛型在现代编程语言中被广泛使用，这里不谈Go缺失泛型是否是一种糟糕的设计，纯粹前段时间在gvisor的代码中看见一种实现泛型的方式比较新奇，因此拿来记录一下。 老套路由于Go本身并不支持泛型，常见的编程套路有以下几种： 尽可能的重复自己：常见食用方式即使用vim宏、sublime、vscode提供的多行编辑与正则替换功能，来达到Write Once, Paste Anywhere的目的。这也是广大人民最喜闻乐见的黑Go的方式，比如下面这张图： 尽可能的使用空接口和map：为了实践Don’t Repeat Yourself的金玉良言，各路神仙纷纷使用起interface{}配合嵌套map[string]interface{}.完美,要用啥再下断言。毕竟超过两次的就需要抽象了，而空接口是一切抽象最终形态: 只要你想，空接口这种抽象能够装下整个宇宙。 利用工具生成代码：整一个模板抠几个洞，佐上Jinja2、Mustache、Go Template啥的，基于字符串把我要的类型替换进去。啥？你说基于字符串的替换没有语义，不能用编译器检查与法还容易错？拜托，又不是不能用，要啥自行车？至于自动化嘛，其实go generate还是能用的，至少比没有好对吧。 新亮点gvisor项目里，third_party/gvsync这个包利用了Blaze+一个小工具，实现了一个简单的泛型方案。虽然不可能从语言级别上让出发已久的Go支持泛型，不过这也是一种比较优雅的方案了。这个方案本质上属于上面的套路3，是一种基于模板的泛型方案，但是更精致一些。 依赖于构建工具Balze，在构建的时候按需生成代码。模板只写一份，哪个包用到这个泛型算法，就在那个中声明依赖和目标类型即可。而不是在泛型算法提供者那生成一大堆wrapper，真正做到了泛型想做到的解耦。 类型安全：模板只是一个普通的Go源代码文件，可以被编译器进行语法检查，甚至运行测试。 基于AST，而不是简单的字符串替换。直接操作抽象语法树，把模板源代码文件中的某一个类型替换为目标类型，不但保证序列化后的代码一定合法，而且实现了如果出现同名的元素不会被错误的替换，甚至在新的子作用域中，不会替换自作用域中同名的元素。 细节要实现这个功能，需要一个命令行工具对模板进行渲染，以及构建系统的支持从而实现自动化构建。 渲染工具这个渲染工具是gvisor为了在项目里使用而写的，并非一个专业的渲染模板。但是就功能上而言，应该已经能够胜任Go在泛型渲染上的需求。这个工具的代码位于tools/go_generics，主要功能就在此的3个文件之内，不到500行代码里。处理的流程大致按照以下步骤： 将单个Go源码文件读入内存并利用标准库中自带的Parser解析到AST； 把注释和import信息统计进map，以供生成代码的时候去除不需要的注释和依赖包； 遍历AST，对Global作用域内的节点以及别处的引用按照Cmd Flag中的设置进行替换； 遍历AST，删除原始类型的定义； 依照魔改后的AST，对照过程（2）中map中的信息重新生成新的Go源码。 利用这个工具，能够做到一下事情： 将模板中定义的一个类型按照Go的语义重构成一个新的类型； 将模板中定义的用来占位的类型以及其方法完全删除； 将模板中的类型以及函数添加后缀，并修改此类型的引用（例如类型断言等）； 修改全局定义的常量以及包名。 构建工具集成Blaze的类Python的语法提供了极大的自由度，在tools/go_generics/defs.blz中定义了上述命令行工具的wrapper。利用这个封装，任何模块下的BUILD脚本都可以import这个定义文件，从而支持泛型模板的渲染。 _go_template_instance_impl实现了对命令行工具的封装，把命令行的Flag都封装成了一个配置对象。 在BUILD中import上述定义文件，比如third_party/gvsync。在这个包里，generic_atomicptr.go和generic_seqatomic.go便是一个泛型。以后者为例，使用这个泛型的测试的BUILD文件：third_party/gvsync/seqatomictest/BUILD中所定义的：12345678910go_template_instance( name = \"seqatomic_int\", out = \"seqatomic_int.go\", package = \"seqatomic\", suffix = \"Int\", template = \"//third_party/gvsync:generic_seqatomic\", types = &#123; \"Value\": \"int\", &#125;,) 将third_party/gvsync/seqatomic_unsafe.go作为模板，将Value类型换成int类型，并在导出的方法和类型后添加Int后缀。比如原本的func SeqAtomicLoad(sc *gvsync.SeqCount, ptr *Value) Value方法，经过渲染的结果则为func SeqAtomicLoadInt(sc *gvsync.SeqCount, ptr *int) int。 结论Go没有泛型的支持，的确对代码的表现能力进行了极大的限制；而众多泛型的山寨版本也没一个好用的，本文提到的这种方式至少也提供了一种尝试。好处：泛型算法提供者和使用者解耦了，使用源生Go代码作为模板，支持测试和补全等；坏处：使用难度较高，心智负担不比直接支持泛型低，甚至更高。 所以，Go Sucks","categories":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/tags/Golang/"},{"name":"Balze","slug":"Balze","permalink":"https://reficul.io/tags/Balze/"},{"name":"generic-type","slug":"generic-type","permalink":"https://reficul.io/tags/generic-type/"}]},{"title":"Shadowsocks-go 源码分析","slug":"Shadowsocks_go_source_code_analysis","date":"2016-05-12T01:11:00.000Z","updated":"2021-02-21T17:44:28.139Z","comments":true,"path":"2016/05/12/Shadowsocks_go_source_code_analysis/","link":"","permalink":"https://reficul.io/2016/05/12/Shadowsocks_go_source_code_analysis/","excerpt":"Shodowsocks是一个小有名气的代理工具，主要致力于减小流量特征，从而达到GFW无法对其进行定向的封杀的目的。Shadowsocks有多种语言的实现，本着学习一下原理的心态，看了一下其用Go版本的实现细节。","text":"Shodowsocks是一个小有名气的代理工具，主要致力于减小流量特征，从而达到GFW无法对其进行定向的封杀的目的。Shadowsocks有多种语言的实现，本着学习一下原理的心态，看了一下其用Go版本的实现细节。 项目结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354.├── CHANGELOG├── cmd│ ├── shadowsocks-httpget│ │ └── httpget.go│ ├── shadowsocks-local│ │ └── local.go //ss-local主程序│ └── shadowsocks-server│ └── server.go //ss-server主程序├── config.json├── deb //DEB打包配置│ ├── DEBIAN│ │ ├── conffiles│ │ ├── control│ │ ├── postinst│ │ ├── postrm│ │ └── prerm│ └── etc│ ├── init.d│ │ └── shadowsocks│ └── shadowsocks│ └── config.json├── LICENSE├── Makefile //利用Makefile编译安装，安装位置在$GOPATH/bin├── README.md├── sample-config //配置范例│ ├── client-multi-server.json│ └── server-multi-port.json├── script│ ├── build.sh│ ├── createdeb.sh│ ├── curl.sh│ ├── http.go│ ├── README.md│ ├── set-version.sh│ ├── shadowsocks.exe│ ├── test.sh│ └── win32build.bat├── shadowsocks //实现了Shadowsocks包│ ├── config.go //配置解析│ ├── config_test.go│ ├── conn.go //实现了shadowsocks.conn接口，类似net.conn│ ├── encrypt.go //一个封装好的加密库│ ├── encrypt_test.go│ ├── leakybuf.go //一个缓存的实现，避免频繁申请释放内存│ ├── log.go│ ├── mergesort.go //快排(历史遗留问题？Initial commit用到了，现在最新的代码没找到使用)│ ├── pipe.go //对shadowsocks.conn的一个管道封转，用于连接建立后的流量转发│ ├── proxy.go //封装的shadsowsock库，直接与远端ss-server建立连接│ ├── testdata│ │ ├── deprecated-client-multi-server.json│ │ └── noserver.json│ └── util.go //工具集└── TODO 没有实现关于UDP的支持，没有支持Tcp fast open，GoLang的官方网络库貌似还没有支持TFO 核心组件 shadowsocks/conn.go 其具体的通信过程为： 调用RawAddr函数，获取目标服务器地址和端口，并将其封装为以下的格式: 12345+------+-----+-----------------------+------------------+-----------+| ATYP | Len | Destination Address | Destination Port | HMAC-SHA1 |+------+-----+-----------------------+------------------+-----------+| 1 | 1 | Variable | 2 | 10 可选 |+------+-----+-----------------------+------------------+-----------+ ATPY写死了为0x03，其代表了地址类型为域名 Len是地址（域名）的长度 随后的端口是网络序-大端写入的 HMAC校验，当开启一次验证之后会附加在最后，占地10Byte，由IV+key为Key，对前面所有信息的摘要。 DialWithRawAddr函数拿到以上的请求，ss服务器地址以及加密信息之后，向ss服务器发起tcp连接： 首先如果OTA被启用了，会提前生成IV，并立即向ss服务器发送，随后通过shadowsocks.write完成加密Request并发往ss服务器。 12345+-------+---------------+| IV | Encryped Data |+-------+---------------+| Fixed | Variable |+-------+---------------+ 如果OTA为启用，则会直接把请求用Write函数尝试发出，但是发现加密方法未初始化，则初始化IV与Chipher，并将IV附加在加密信息之后一起发出。 看Shadowsocks文档显示应该是同时发出的，但是因为tcp是个流，貌似也可以？ 12345+-------+ +---------------+| IV | | Encryped Data |+-------+ +---------------+| Fixed | | Variable |+-------+ +---------------+ 如果一切正常，则返回连接句柄。 此时ss-local与ss-server应该已经建立一个TCP连接，数据发送接受已经就绪。而且ss-local已经生成IV与加密方法，ss-server也已经接受到IV并完成了解密方法的初始化。 至此，握手阶段结束，剩下的就是pipe通信阶段。 shadowsocks/pipi.go 这个文件中的函数用io包对shadowsocks.conn进行了一个封转，实现了对流量的转发。 转发中，因为已经完成了握手，则数据直接通过pipe进行转发。 在OTA未启用时，即是简单的一个循环，除非转发中出现异常，否则无脑转发。 在OTA启用后，则需要对数据解包，对数据进行校验，只有通过才能被转发，否则pipe将被关闭. 解密之后，包结构如图：第3到12字节为HMAC-SHA1验证信息，是由IV+chunkId为Key，对DATA做的HMAC摘要，本地计算后与包中的相等，则校验通过。 12345+----------+-----------+----------+----| DATA.LEN | HMAC-SHA1 | DATA | ...+----------+-----------+----------+----| 2 | 10 | Variable | ...+----------+-----------+----------+---- cmd/shadowsocks-server/server.go以及cmd/shadowsocks-local/local.go 这个文件为ss-server与ss-local的主程序，完成了代理服务器的作用。 local.go这个程序在本地架设了一个Socks5服务器，接收来自浏览器等应用程序的请求。 依据socks5协议，应用程序会向SOCKS5服务器发送一个握手请求，SOCKS5服务器返回正确信息则握手成功。 随后应用程序向SOCKS5服务器发送代理请求，此时我们的local会解析这个请求，并告诉应用程序，请求已经被接收。随后解析请求，获取目标服务器的地址与端口，用之前shadowsocks.conn中的Dial函数对ss服务器发起请求，等待服务器连接建立，随后两个加密pipe建立，转发来自应用程序到目标服务器的所有流量。 应用程序在收到SOCKS5服务器返回的请求接受回复后，开始向SOCKS5发送数据，数据经过local转发到server再转发到真实的服务器，并原路返回。 server.go这个程序在墙外监听着端口，并时刻准备与local握手，建立pipe，转发数据。GO版本的Server实现了多端口不同密码，即实现了多用户不同密码不同端口。local实现了多服务器，并按照握手失败次数加权，优先连接优质服务器。 一次验证： 每次向io接口中写入数据，或者验证的时候，都会自增一次ChunkID，ChunkID+随机的IV，保证以往的数据包不能被用以重放攻击。","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://reficul.io/categories/Shadowsocks/"}],"tags":[{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"https://reficul.io/tags/ShadowSocks/"},{"name":"go","slug":"go","permalink":"https://reficul.io/tags/go/"},{"name":"sourcecode","slug":"sourcecode","permalink":"https://reficul.io/tags/sourcecode/"}]},{"title":"Golang中[]Byte与string类转换时内存并不共享","slug":"Golang-byte-string-dont-share-menory","date":"2016-04-19T20:51:00.000Z","updated":"2021-02-21T17:44:28.139Z","comments":true,"path":"2016/04/19/Golang-byte-string-dont-share-menory/","link":"","permalink":"https://reficul.io/2016/04/19/Golang-byte-string-dont-share-menory/","excerpt":"在Golang的基础中我们知道在用append的时候，或者Slice底层数组小于需求容量的时候，Go会自动重新分配内存，随之带来的有一次值拷贝。在数据量小或函数调用不频繁的时候对性能的损失并不明显，但是如果在高频率调用或者数据量大的时候，性能损失不能忽略不计。","text":"在Golang的基础中我们知道在用append的时候，或者Slice底层数组小于需求容量的时候，Go会自动重新分配内存，随之带来的有一次值拷贝。在数据量小或函数调用不频繁的时候对性能的损失并不明显，但是如果在高频率调用或者数据量大的时候，性能损失不能忽略不计。 那么那些情况会触发值拷贝呢？我们来逐一测试： []byte截取： 123456789101112pckage mainimport \"fmt\"func main() &#123; str := []byte(\"this is a fucking string\") str2 := str[0:5] str3 := str2[0:2] fmt.Printf(\"%p\\n\", str) fmt.Printf(\"%p\\n\", str2) fmt.Printf(\"%p\\n\", str3)&#125; 输出： 0xc82000e4e00xc82000e4e00xc82000e4e0 分析： 对[]byte进行了两次切片操作，首地址不变。这也说明了这三个Slice使用了同一个底层数组，并不发生值拷贝。 string与[]byte互相转换: 123456789101112package mainimport \"fmt\"func main() &#123; str := []byte(\"this is a fucking string\") str2 := string(str) str3 := []byte(str2) fmt.Printf(\"%p\\n\", str) fmt.Printf(\"%p\\n\", &amp;str2) fmt.Printf(\"%p\\n\", str3)&#125; 输出： 0xc82000e4e00xc82000a3300xc82000e520 分析： 无论从[]byte到string还是string到[]byte，他们的指针地址均不同。说明在类型转换的时候，发生了值拷贝，而[]byte与string并不共享内存。 查阅资料，发现老外有一篇文章也证明了这个观点： 从Golang Runtime源代码来看，[]byte与string的转换分别调用了以下两个函数： runtime.stringtoslicebyte() runtime.slicebytetostring() 1234567891011121314151617func slicebytetostring(b Slice) (s String) &#123; void *pc; if(raceenabled) &#123; pc = runtime·getcallerpc(&amp;b); runtime·racereadrangepc(b.array, b.len, pc, runtime·slicebytetostring); &#125; s = gostringsize(b.len); runtime·memmove(s.str, b.array, s.len);&#125;func stringtoslicebyte(s String) (b Slice) &#123; b.array = runtime·mallocgc(s.len, 0, FlagNoScan|FlagNoZero); b.len = s.len; b.cap = s.len; runtime·memmove(b.array, s.str, s.len);&#125; 可以看到其中menmove这些内存移动操作。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/tags/Golang/"},{"name":"技术","slug":"技术","permalink":"https://reficul.io/tags/%E6%8A%80%E6%9C%AF/"}]},{"title":"Go Get Golang.org失败的原因","slug":"Why_Golang_com_fail","date":"2015-11-30T21:36:00.000Z","updated":"2021-02-21T17:44:28.139Z","comments":true,"path":"2015/11/30/Why_Golang_com_fail/","link":"","permalink":"https://reficul.io/2015/11/30/Why_Golang_com_fail/","excerpt":"最近在碰到一个很奇怪的问题，Go get工具在下载golang.org/x/tools下源代码的时候总是失败，但是以前并没有这个问题。Chrome已经使用了Shadowsocks穿墙，但是直接访问这个URL后发现在显示Nothing to see here之后就跳转到了文档页面。本以为是Google Code关闭带来的影响。不过时间过去了一周，并没有改善，奇怪的是老外对此并没有哀嚎遍野。为此有必要看一下go get到底发生了啥了。","text":"最近在碰到一个很奇怪的问题，Go get工具在下载golang.org/x/tools下源代码的时候总是失败，但是以前并没有这个问题。Chrome已经使用了Shadowsocks穿墙，但是直接访问这个URL后发现在显示Nothing to see here之后就跳转到了文档页面。本以为是Google Code关闭带来的影响。不过时间过去了一周，并没有改善，奇怪的是老外对此并没有哀嚎遍野。为此有必要看一下go get到底发生了啥了。 无意中翻到一篇讲述了Go get的过程的文章：https://texlution.com/post/golang-canonical-import-paths/. 文章的意思很简单，大概说的是Go get工具会去所Import的路径下载代码，如果没有，会寻找meta标签中的别名/镜像Repo。 ➜ curl golang.org/x/tools/cmd/rename &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt; &lt;meta name=&quot;go-import&quot; content=&quot;golang.org/x/tools git https://go.googlesource.com/tools&quot;&gt; &lt;meta name=&quot;go-source&quot; content=&quot;golang.org/x/tools https://github.com/golang/tools/ https://github.com/golang/tools/tree/master{/dir} https://github.com/golang/tools/blob/master{/dir}/{file}#L{line}&quot;&gt; &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0; url=https://godoc.org/golang.org/x/tools/cmd/rename&quot;&gt; &lt;/head&gt; &lt;body&gt; Nothing to see here; &lt;a href=&quot;https://godoc.org/golang.org/x/tools/cmd/rename&quot;&gt;move along&lt;/a&gt;. &lt;/body&gt;而我们之前看到的Nothing to see here只是一个假象，meta标签并不被浏览器显示。傻傻的以为Repo真的被迁移了。 这才发现到了学校之后一直用的SS-local+SwitchOmega上网，并没有配置OpenWrt的透明代理，这才主观上感觉最近Golang.org才挂掉。 总结不是Golang.org代码迁移了，是撞墙了。 解决方案： Proxychains+Shadowsocks的临时使用方案 OpenWrt+Shadowsocks透明代理一次部署，一劳永逸方案 从Github上Get下来，一条条的手动下载。","categories":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/categories/Golang/"}],"tags":[{"name":"Golang","slug":"Golang","permalink":"https://reficul.io/tags/Golang/"},{"name":"GFW","slug":"GFW","permalink":"https://reficul.io/tags/GFW/"}]},{"title":"30天自制操作系统-第二次开启填坑","slug":"Goo-OS_1","date":"2015-07-18T01:34:00.000Z","updated":"2021-02-21T17:44:28.139Z","comments":true,"path":"2015/07/18/Goo-OS_1/","link":"","permalink":"https://reficul.io/2015/07/18/Goo-OS_1/","excerpt":"第二次开始填坑，没有压力真没有动力。老是觉得这样不行那样不行，直到To Do List的堆栈爆了还没动一点点，那还不如开始动手做。上次的进度是认识了实模式，并成功进入了32位模式下，启用了分段的内存管理，打开了保护模式，然后用指针操作了个Demo就草草结束了。","text":"第二次开始填坑，没有压力真没有动力。老是觉得这样不行那样不行，直到To Do List的堆栈爆了还没动一点点，那还不如开始动手做。上次的进度是认识了实模式，并成功进入了32位模式下，启用了分段的内存管理，打开了保护模式，然后用指针操作了个Demo就草草结束了。 这次重新填坑，碰到了很多问题，但是归根到底是经验太缺乏。之前用了GNU一套工具链，自然有的步骤开始脱离书本，想化为己用还是火候不到，碰到了一些问题要花很久才能解决。 书本上还是用的纯汇编来作为C语言的补充，写了一些函数。之前正好看了一些公开课，诶就是网易孟宁老师的Linux内核，看着内联汇编的实现。那这次就用内联汇编吧。敲代码很快，把这些函数作为一个C的库单独解耦出来，命名为lib.c/libc.h编译出了很多错，后来都一一解决了。分别是： Intel风格汇编和A&amp;AT风格汇编的不兼容，之前看的和书本上都是Intel风格的，一时不习惯，编译不能通过。在Makefile中加入编译选项，-masm=intel后解决。 编译提示Push，Pop，MOV等命令与对操作的数据不匹配，折腾后发现我的操作系统是Debian x64位，安装的工具链是64位，再加入编译选项-m32后提示找不到头文件，通过apt-get安装完依赖后解决。 终于编译完毕，make run伴随着一声强烈有力清脆的回车声，大爷的黑屏了。调试了4个小时，此时我的内心是崩溃的。debug过程很蛋疼，因为没法跟踪调试各个参数和查看变量的值，只能注释修改大法，然后发现在io_out8这个函数这里有问题，因为我把这个循环执行一半（把for循环中的end改为个较小数），发现这调色盘是写过的全黑了。辣么不是这个函数有问题就是数据有问题，但是怎么看都不像是数据有问题啊，数组敲错那也不会全黑啊。于是对函数进行编译，反汇编，怀疑是数据类型的问题，因为就传出8位，int等比这个大。折腾了int8_t和int16_t这些，并引入更多的头文件。但是还是不管用，内心崩溃下重新用nasm作为工具，用纯汇编实现了这些函数。结果很高兴的告诉我我内联汇编实现的不错，因为内联汇编是正确的，纯汇编也黑了，以上4小时我再白费工夫。纠结下在bootmain.c中的io_out8()函数中敲入了立即数0xff，0xff，0xff。白屏了，这更说明了函数编写的都是正确的，那么为啥用static unsighed char定义的数组突然不管用了呢？打开Makefile，objcopy -j .text -O binary bootblock.o bootblock.tmp,真想抽自己，我把数据段删了，我把数据段删了，我把数据段删了…………删了……去掉-j .text之后，一切正常了。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://reficul.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"https://reficul.io/tags/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C语言","slug":"C语言","permalink":"https://reficul.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"内联汇编","slug":"内联汇编","permalink":"https://reficul.io/tags/%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"}]},{"title":"30天自制操作系统-第0天，环境搭建","slug":"30-0","date":"2015-02-06T01:25:00.000Z","updated":"2021-02-21T17:44:28.139Z","comments":true,"path":"2015/02/06/30-0/","link":"","permalink":"https://reficul.io/2015/02/06/30-0/","excerpt":"书买了半个月了，也看了前几天的量了。不过一直没动手敲代码，那便不算开始罢。书看得出日文版截稿比较早，内容环境还是基于WinXP（貌似写的WinXP都是时新货的样子XD）光盘附带的工具看得出都是Linux下的一套，Qemu，make，gcc，Makefile。之前架设这个博客的时候就受过惨痛教育（Hexo基于Node.js，上传工具用Git。在windows下用起来，别扭不说，突出一个蛋疼。）于是准备在Debian下部署环境。","text":"书买了半个月了，也看了前几天的量了。不过一直没动手敲代码，那便不算开始罢。书看得出日文版截稿比较早，内容环境还是基于WinXP（貌似写的WinXP都是时新货的样子XD）光盘附带的工具看得出都是Linux下的一套，Qemu，make，gcc，Makefile。之前架设这个博客的时候就受过惨痛教育（Hexo基于Node.js，上传工具用Git。在windows下用起来，别扭不说，突出一个蛋疼。）于是准备在Debian下部署环境。 好的吧，本书看样子截稿是挺久远了，工具下载页面也年久失修啦。打开则纯HTML风迎面飘来。另存到本地，打开后GOOGLE翻译下，有Linux的环境可以直接下载。可是其中内容也是GCC，也是make，何必用他的捏。好吧，这是强迫症，得治疗。自己定义了源代码的目录结构，Makefile准备在以后看书的时候再慢慢写呗。 首先是虚拟机模拟环境：qemu的执行命令和旧版本也有些许不同。旧的命令参考作者网站给出的链接也应该是qemu -m 32 -localtime -STD-VGA -FDA &#39;XXXX.img&#39;而由Apt-get到的版本则是qemu -m 32 -localtime -vga std -fda xxx.img 不过都不是大问题，很快就解决了。但是在链接 C和汇编 Obj文件的时候，出了问题。原书用的是nask，一个修改版的nasm。比起远古版本的nask，我选择了nasm。在这我参考在MAC上搭建环境的这篇文章。所以也用了他的测试代码。编译没有问题，很顺利，可是在链接过程报错了。尝试修改掉汇编源代码中符号前的下划线，并且连接时去掉main前的下划线。再次报错，不过错误减少。看样子和架构有关，但是两个obj文件都已经用参数定义为32位。挠头后一无所获。将两个文件都重新以64位编译，链接成功。但是执行的时候提示段错误。意识到可能ld链接也区分32位和64位。重新查看参数，加入-m elf_i386选项，链接成功，执行成功。 最后环境如下： 由nasm编译nas汇编文件 由GCC编译 C语言文件 由GNU make管理编译过程 由Qemu来做虚拟机，模拟启动。 以上都可以由apt-get获取。 总结 搜索相关结果，旧版本GCC为了兼容老库，会自动添加下划线。而新版本的GCC不再在编译时向符号名中添加下划线。但是可以由选项重新开启这个功能。 ld链接也区分系统架构，mac不需要加选项可能是32位？反正是因为环境不同（在这点上，我傻逼了）。","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://reficul.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"30天自制操作系统","slug":"30天自制操作系统","permalink":"https://reficul.io/tags/30%E5%A4%A9%E8%87%AA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"GCC","slug":"GCC","permalink":"https://reficul.io/tags/GCC/"},{"name":"汇编","slug":"汇编","permalink":"https://reficul.io/tags/%E6%B1%87%E7%BC%96/"},{"name":"C语言","slug":"C语言","permalink":"https://reficul.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"在Azure搭建ShadowSocks国内跳板，并开启UDP转发。","slug":"Shadowsocks-relay-based-on-Azure","date":"2015-02-05T01:11:00.000Z","updated":"2021-02-21T17:44:28.139Z","comments":true,"path":"2015/02/05/Shadowsocks-relay-based-on-Azure/","link":"","permalink":"https://reficul.io/2015/02/05/Shadowsocks-relay-based-on-Azure/","excerpt":"买BandwagonHost的VPS已经很久了，现在主要也是给朋友用。随着SS名声的变大，搬瓦工这个名字也在圈子里响当当了。用多了加上墙的变高，上海精品网等等的出现，速度越来越不理想。想来国内Azure还在免费，所以拿来搭个跳板机，速度应该会有一些提高。","text":"买BandwagonHost的VPS已经很久了，现在主要也是给朋友用。随着SS名声的变大，搬瓦工这个名字也在圈子里响当当了。用多了加上墙的变高，上海精品网等等的出现，速度越来越不理想。想来国内Azure还在免费，所以拿来搭个跳板机，速度应该会有一些提高。 找到SS的WIKI，搭建一个转发只需要两行Iptables规则，但是根据作者说性能不如Haproxy。由于不需要负载平衡，所以直接照抄方案二的代码就完成了转发服务器的搭建。随之问题来了，UDP转发功能废了。无奈中，搜索得知Haproxy无法转发UDP包。不能转发UDP则不能借助SS-tunnel转发DNS来解决DNS投毒，更不能让走代理的流量获取最快的节点。这显然不能接受。然而正好咱不需要负载平衡，而且用户一只手掰得过来，想来内核级别的iptables性能应该不会差到哪去，并且这种无差别的转发一定是可以支持SS的UDP转发功能的。于是打定主意使用这个方案。半路出家的我对复杂的iptables设置很是头疼，扒了文章了解后，大概得知我们的需求是由SNAT和DNAT合作完成的。简而言之就是我们的客户机上将服务器设置为我们的跳板机，则数据包发送到跳板机上，然后修改源IP和目标IP地址，重新转发给后面真实的SS服务器上，以此完成整个过程。那么依样画葫芦，摘取一下： iptables -t nat -A PREROUTING -p tcp --dport 8388 -j DNAT --to-destination SS_VPS_IP:8388 iptables -t nat -A POSTROUTING -p tcp -d SS_VPS_IP --dport 8388 -j SNAT --to-source Azure_IP以上只转发TCP包，应该能够实现原本基础的功能了，可是经测试无效。检查了Azure网页中的端口映射,检查了iptables是否打开了转发,FORWARD表默认ACCEPT后都没有排除故障，只好用TCPDUMP抓取数据包。抓包后发现，在Azure的机器上，iptables出色的完成了预计的任务（如图）。可是在SS服务器上，则是一个包都没进得来。挠头之余，很是无奈啊。后来发现，Azure在外层有一层NAT，所给虚拟机的IP虽然是公网IP，但是不是绑定在虚拟机网卡上的IP。Azure的防火墙在收到数据包后进行一次NAT，转发给内部虚拟机。出去的数据包也经过一次NAT，之后才进行发送。虽然在出咱虚拟机网卡的包的目标地址被正确的修改，指向了SS-vps，但是源地址是该虚拟机的外网IP（Azure叫他：公用虚拟 IP (VIP)地址），这个包在经国Azure的外围防火墙的时候被丢弃，因为认为这个包的源IP不是内部的服务器的。修改规则后，测试成功。并且SS-tunnel正常。修改后代码如下： iptables -t nat -A PREROUTING -p tcp --dport 8388 -j DNAT --to-destination SS_VPS_IP:8388 iptables -t nat -A PREROUTING -p udp --dport 8388 -j DNAT --to-destination SS_VPS_IP:8388 iptables -t nat -A POSTROUTING -p tcp -d SS_VPS_IP --dport 8388 -j SNAT --to-source Azure内部 IP 地址 iptables -t nat -A POSTROUTING -p udp -d SS_VPS_IP --dport 8388 -j SNAT --to-source Azure内部 IP 地址这个事情真的是会的不难，难的不会，加上有个暗坑（Azure的防火墙），让本来不复杂的事情变得困难了一些。不过好处是，在给了我动力和机会实践学习了Iptables的一些概念和命令。对表，链，规则有了基本的认识学习。收益颇多，也做个笔记。 December 7 2015 Updated:腾讯云测试可用","categories":[{"name":"Shadowsocks","slug":"Shadowsocks","permalink":"https://reficul.io/categories/Shadowsocks/"}],"tags":[{"name":"ShadowSocks","slug":"ShadowSocks","permalink":"https://reficul.io/tags/ShadowSocks/"},{"name":"iptables","slug":"iptables","permalink":"https://reficul.io/tags/iptables/"},{"name":"Azure","slug":"Azure","permalink":"https://reficul.io/tags/Azure/"},{"name":"NAT","slug":"NAT","permalink":"https://reficul.io/tags/NAT/"}]},{"title":"Nexus5在Android下开启电信3G心得","slug":"Nexus5 cdma","date":"2014-12-11T10:20:00.000Z","updated":"2021-02-21T17:44:28.139Z","comments":true,"path":"2014/12/11/Nexus5 cdma/","link":"","permalink":"https://reficul.io/2014/12/11/Nexus5%20cdma/","excerpt":"流水账记录一下Nexus 5太子在破解使用电信卡的时候遇到的坑。","text":"流水账记录一下Nexus 5太子在破解使用电信卡的时候遇到的坑。 #需要 一个开启Diag的内核 DFS程序 ADB环境 需要Root以使用Nexus5 Field Test Mode程序 #准备 内核部分，我使用了SykopomposStockLollipopKernel.zip这个内核，原帖源于XDA，我没找到。已经开启了Root，Diag。 ROOT部分使用了CF-root的自动root。 Nexus5 Field Test Mode程序部分直接在Google play上下载的，最新版本已经支持了Android 5.0。破解过程遵循《NEXUS 5中文完美电信3G 2.0版》，没啥再加工的和自我创造，我要说的是几点心得。 #心得 在5.0下面也可破解电信，应该无需刷回4.4.2 PRL可以通过短信更新，发短信内容“PRL到”10659165，将受到6条短信，并且提示更新成功。当然前提是能发短信了才能用这个方法更新PRL。 老是显示禁用漫游提示符是因为SID没写，找到NAM选项卡HOME下的SID，写入自己所在归属的的SID，可以搜索下，能找到的。写入立即可以修复禁用漫游提示符的问题，但是如此修改后虽然提示搜到了电信信号但是还是不能打电话发短信，那说明变回了NV-only，需要再改这个。这个变回原理未知，无规律变回。但是SID和这项一起修改貌似可以减少变回的概率。别的分析在《NEXUS 5中文完美电信3G 2.0版》也有说明，可参考。 APN默认是荷兰的一家运营商，同样可以通过修改APN来解决上网问题，不需换卡。我的卡是换Nexus5才换的小卡，所以要换也没有别的卡可以换了，实测这个不影响根本问题，是同样可以使用电信的。 修改APN方面，可以使用海卓。但是在4.0以后得系统中，海卓不再拥有权限修改APN。有个变通的方法是将其变成系统程序。利用钛备份高级版功能，转化为系统APP，然后将/system/app下的海卓apk剪切到system/priv-app下，即可恢复权限，自动修改APN。 PS：变成荷兰之后，因祸得福一件事情。虽然微信等APP自动填写的电话会变成+31要修改，多点击两次略麻烦，但是，Google服务也会把你当作荷兰用户。所以无需root，无需安装local report enabler。修改语言清空Google搜索的数据，即可食用各项谷歌服务，Google now，fit点击就送@。@ 刷完之后没有3G，但是可以打电话，发短信。不能彩信，上网。设置了APN均无效。信号的确是CDMA-EVOD Rev.a 但是信号不咋地，很容易掉到1格。 这个问题消耗了我大约6个小时时间。网络上大多评论换卡的问题，或者是字库被修过等硬件问题。诶，险些让人失去信心啊。其实貌似关键在于DATA选项卡下面的HDR AN和HDR AN LONG上，经过一晚上仅仅修改上面的PPP和PAP失败之后，第二天早上将HDR AN和HDR AN LONG清空之后再写入，问题莫名其妙的好了。 PS：在不停重试写DATA的时候，PWD密码和PPP，PAP改写的还是要写的，读不出来是正常的。 在一切OK之后，3G信号变成了满格，一切正常，彩信也正常。 从4.4.X升级到5.0无需重新破解，无需备份还原等操作，只需要下载Factory image解压后和ADB合体，或者安装ADB之后cd到解压的文件夹，把flash-all.bat/flash-all.sh中的fastboot后面的-w参数删除，直接线刷即可升级到最新的系统。","categories":[{"name":"日志","slug":"日志","permalink":"https://reficul.io/categories/%E6%97%A5%E5%BF%97/"}],"tags":[{"name":"电信","slug":"电信","permalink":"https://reficul.io/tags/%E7%94%B5%E4%BF%A1/"},{"name":"Android 5.0","slug":"Android-5-0","permalink":"https://reficul.io/tags/Android-5-0/"}]}]}